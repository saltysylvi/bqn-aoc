# input and parsing
input â† â€¢FLines "inputs/05.txt"
Nats â† {10âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½Â¨'0'-Ëœğ•©âŠ”Ëœ1-Ëœâˆ§âŸœ(+`>âŸœÂ»)ğ•©âˆŠ'0'+â†•10}
seeds â† Nats âŠ‘input
maps â† {>NatsÂ¨ 1â†“ğ•©}Â¨ ((âŠ¢-ËœÂ¬Ã—+`)âŸ¨âŸ©âŠ¸â‰¡Â¨)âŠ¸âŠ” 2â†“input

# Part 1 Strategy:
# Convert each map into bins and offsets.
# The bins are in the format to be left arg to â‹
# The offsets are the numbers we need to add to the
# input if the input falls inside the corresponding range.
# To process inputs by a map:
#  - get bin index (binsâ‹inputs)
#  - index into offsets (offsetsâŠËœbinsâ‹inputs)
#  - add offsets to inputs (inputs+offsetsâŠËœbinsâ‹inputs)
# To process inputs for all maps left fold (ËœÂ´âŒ½) over the maps

# bins and offsets
bo â† {
    m â† â‰ğ•©âŠËœâ‹1âŠâ‰ğ•©         # sort map by range starts, transpose for convenience
    [s,e] â† +`1â†“m         # range starts (inclusive) and ends (exclusive)
    o â† -Ë2â†‘m             # offsets for each range
    g â† eâ‰ Â«s              # gaps when a range doesn't touch the next range
    b â† âˆ§sâˆ¾g/e            # bins are all the starts, plus the ends that are not starts, sorted
    i â† 1-Ëœ/1âˆ¾g           # indices to insert zeros after in the offsets (need zeros for gaps and outside the map)
    o â†© ((â†•â‰ o)âˆ¾i)â‹âŠ¸âŠoâˆ¾0Â¨i # insert zeros by appending and shuffling into place
    bâ€¿o                   # return bins and offsets
}Â¨ maps

Step â† {sğ•Šbâ€¿o: s+oâŠËœbâ‹s}
â€¢Show âŒŠÂ´seeds StepËœÂ´âŒ½ bo

# Part 2 Strategy:
# Do the same thing as part 1, as much as possible
# The crux is implementing an analog of bins up that works on a single interval right argument
# Since an interval can be in multiple bins at once, our interval bins up (IBins) will
# return not only the bin indices, but an array of sub-intervals corresponding to the indices
# E.g. 2â€¿8â€¿10 IBins [5â€¿12] â†’ âŸ¨1â€¿2â€¿3, [5â€¿7,8â€¿9,10â€¿12]âŸ©
# all intervals will be represented with *inclusive* endpoints!

iseeds â† (0â€¿1-Ëœ+`)âŒ¾â‰ âˆ˜â€¿2â¥Šseeds # get seed ranges, subtracting 1 from ends to make inclusive

# the block function only handles one interval at a time
# The stuff before and after makes it handle a whole array of intervals properly
IBins â† (âŠ‘Ë˜â‹ˆ1âŠ¸â†“âŒ¾â‰)Â·âˆ¾{    # join into one âˆ˜â€¿3 array, split out first column
    i â† (âŠ£+â†•âˆ˜Â¬Ëœ)Â´ğ•¨â‹ğ•©     # get bin indices of start and end, expand into range (7â€¿10 â†’ 7â€¿8â€¿9â€¿10)
    s â† â¥ŠÂ¯1â€¿0+âŒœğ•¨âŠËœÂ¯1â†“i   # find all the bin boundaries the interval crosses, treating each boundary as an end, start pair
    a â† âˆ˜â€¿2â¥Šâˆ§ğ•©âˆ¾s         # insert into the interval the split points, reshape to array of intervals
    iâ€¿a                  # return indices and intervals
}â‰1                      # operate on lists/rows

Step2 â† {sğ•Šbâ€¿o: iâ€¿aâ†b IBins s â‹„ a+iâŠo} 
â€¢Show âŒŠÂ´â¥Šiseeds Step2ËœÂ´âŒ½ bo
